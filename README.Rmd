---
    output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```
# vlad [![Build Status](https://travis-ci.org/wittenberg/vlad.svg)](https://travis-ci.org/wittenberg/vlad) [![Licence](https://img.shields.io/badge/licence-GPL--3-blue.svg)](https://www.gnu.org/licenses/gpl-3.0.en.html)  [![Coverage Status](https://codecov.io/gh/wittenberg/vlad/graph/badge.svg)](https://codecov.io/github/wittenberg/vlad?branch=master)

An R-package which contains functions to set up risk-adjusted quality control charts in health care.

## Main features

- Risk-adjusted CUSUM chart based on log-likelihood ratio statistic
- Risk-adjusted CUSUM chart based on E-O
- Algorithms are implemented using Rcpp, RcppArmadillo
- High performance with parallel computation

## Installation

You can install the released version of **vlad** from [CRAN](https://CRAN.R-project.org) with:

``` r
install.packages("vlad")
```

And the development version from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("wittenberg/vlad")
```
## Example


Load libraries:
```{r load libraries, message=FALSE}
library("vlad")
library("spcadjust")
library("dplyr")
library("tidyr")
library("ggplot2")
```

Subset the dataset `cardiacsurgery` into Phase I (first two years) and Phase II (five years) and estimate a risk model based on `phaseI`.
```{r estimate risk model}
data("cardiacsurgery")
cardiacsurgery <- cardiacsurgery %>% mutate(phase=factor(ifelse(date < 2*365, "I", "II")))
phaseI <- filter(cardiacsurgery, phase == "I")
head(cardiacsurgery)
coeff <- round(coef(glm(status ~ Parsonnet, data=phaseI, family="binomial")), 3)
print(coeff)
```

### Create VLADs for seven surgeons
By using the estimated risk model coefficients `coeff`, for each pair of Parsonnet score and operation outcome values, the difference between expected and observed outcome is calculated with the function `calceo`.
Thereafter, differences are cummulated to create the VLAD. This is done for all seven surgeons of the `cardiacsurgery` dataset. Results are saved to the object `vlads7`.
```{r vlads7}
vlads7 <- lapply(1:7, function(j){
  Si <- filter(cardiacsurgery, surgeon == j)
  EO <- sapply(seq_along(Si$Parsonnet), function(i) calceo(df=Si[i, c(4, 3)], coeff=coeff))
  select(Si, surgeon, phase) %>%  mutate(n=1:length(EO), cEO=cumsum(EO))
}) 

```

Create Variable life-adjusted Displays for each surgeon from the object `vlads7`.
```{r VLADS1-7, fig.align='center', fig.width=8, fig.height=10}
vlads7 %>% 
  bind_rows() %>%  
  gather(key="Surgeon", value=value, c(-n, -surgeon, -phase)) %>%
  ggplot(aes(x=n, y=value, colour=phase, group=Surgeon)) +
    geom_hline(yintercept=0, colour="darkgreen", linetype="dashed") +
    geom_line(size = 1.1) + facet_wrap( ~ surgeon, ncol=2, scales="free") +
    labs(x="Patient number n", y="CUSUM E-O") + theme_classic() +
    scale_y_continuous(sec.axis=dup_axis(name=NULL, labels=NULL)) +
    scale_x_continuous(sec.axis=dup_axis(name=NULL, labels=NULL))
```

### Create a VLAD for surgeon 2
```{r vladS2, fig.align='center'}
S2 <- subset(cardiacsurgery, c(surgeon==2), c("phase", "Parsonnet", "status"))
S2I <- subset(S2, c(phase=="I"))
S2II <- subset(S2, c(phase=="II"))
coeff <- coef(glm(status ~ Parsonnet, data=S2I, family="binomial"))
EO <- sapply(1:nrow(S2), function(i) calceo(df=S2[i, c("Parsonnet", "status")], coeff=coeff))

df1 <- data.frame(cbind(subset(S2, select=c("phase")), n=1:nrow(S2), cEO=cumsum(EO)))
df2 <- gather(df1, "variable", value, c(-n, -phase))

p1 <- ggplot(df2, aes(x=n, y=value, colour=phase)) +
  geom_hline(yintercept=0, linetype="dashed") + geom_line() + geom_point() + 
  labs(x="Patient number", y="CUSUM E-O") + theme_classic()
p1
```

### Compute thresholds of a risk-adjusted CUSUM chart for surgeon 2 

 
Upper and lower control limits of the risk-adjusted CUSUM chart based on log-likelihood ratio statistic can be computed with the function `racusum_arl_sim`. The implemention uses parallel simulation and multi-stage search procedure.  
```{r}
# set a random number generator for parallel computations
RNGkind("L'Ecuyer-CMRG")
# number of simulation runs
m <- 10^4
# assign cores
nc <- parallel::detectCores()
# verbose calculation 
UCL_sim <- racusum_arl_h_sim(L0=740, df=S2I[, c("Parsonnet", "status")], coeff=coeff, m=m, RA=2, nc=nc,
                             verbose=TRUE)
# quite calculation
LCL_sim <- racusum_arl_h_sim(L0=740, df=S2I[, c("Parsonnet", "status")], coeff=coeff, m=m, RA=1/2, 
                             nc=nc, verbose=FALSE)
round(cbind(UCL_sim, LCL_sim), 3)
```

### Author

Philipp Wittenberg.

### License

GPL (>= 3)
